# golang内存分配

标签：golang 语言细节 内存分配

内容主要来自[Go源码分析](https://github.com/qyuhen/book/blob/master/Go%201.5%20%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%20%EF%BC%88%E4%B9%A6%E7%AD%BE%E7%89%88%EF%BC%89.pdf)

为什么写这篇文章：看完书的这一章后觉得挺不错的，然后发现自己忘得比较快，做个备忘。

## 概述

内存分配算法的基本策略：

1. 每次从操作系统申请一大块内存（比如1MB），以减少系统调用。
2. 讲申请到的大块内存按照特定大小预先切分成小块，构成链表。
3. 为对象分配内存时，只需要从大小合适的链表中提取一个小块即可。
4. 回收对象内存时，将该小块内存重新归还到原链表，以便复用。
5. 如闲置内存过多，则尝试归还部分内存给操作系统，以降低整体开销。

内存分配器只管理内存块，而不会关心对象状态，不会主动回收内存。垃圾回收器（GC）不负责分配内存，只回收内存，在完成清理操作后，会触发内存分配器回收操作。

## 内存块

内存分配器管理的内存块分为两种：

* span：由多个地址连续的页组成的大块内存
* object:将span按特定大小切分成多个小块，每个小块可以存储一个对象。

从用途上来说，span面向内部管理，object面向对象分配。

用于存储对象的object，按8字节倍数分为n种。这种方式会造成一些内存浪费，但是内存分配器只需要面对有限的几种规格的小块内存，可以优化分配和复用管理策略。

## 管理组件

优秀的内存分配器必须要在性能和内存利用率之间做到平衡。golang采用了tcmalloc的成熟架构。

分配器由三个组件组成：

* cache：每个运行期工作线程都会绑定一个cache，用于无锁object分配。
* central：为所有cache提供切分好的后备span资源
* heap：管理闲置span，需要时向操作系统申请新资源

为什么要为无锁object分配：来自于tcmalloc的数据，普通的free/delete一般要300ns，lock/unlock操作为100ns。

分配流程：

1. 计算待分配对象规格（size class）
2. 从cache.alloc数组找到规格相同的span。
3. 从span.freelist链表提取可用object>
4. 如果span.freelist为空，则从central获取新span。
5. 如果central.nonempty为空，则从heap.free/freelarge获取，并切分成object链表。
6. 如果heap没有大小合适的span，则向操作系统申请新内存块。

释放流程：

1. 将标记为可回收object交换给所属的span.freelist。
2. 该span被放回central，可供任意cache重新获取使用。
3. 如该span已收回全部object，则将其交还给heap，以便重新切分复用。
4. 定期扫描heap里长时间闲置的span，释放其占用内存。

注：大对象（tcmalloc中为大于32K的，会使用页4K为单位进行内存分配的对象）直接从heap分配和回收
